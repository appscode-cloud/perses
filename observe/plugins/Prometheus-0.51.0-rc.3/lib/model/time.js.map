{"version":3,"sources":["../../../src/model/time.ts"],"sourcesContent":["// Copyright 2023 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { AbsoluteTimeRange, DurationString, parseDurationString } from '@perses-dev/core';\nimport { milliseconds, getUnixTime } from 'date-fns';\nimport { UnixTimestampSeconds } from './api-types';\n\nexport interface PrometheusTimeRange {\n  start: UnixTimestampSeconds;\n  end: UnixTimestampSeconds;\n}\n\n/**\n * Converts an AbsoluteTimeRange to Prometheus time in Unix time (i.e. in seconds).\n */\nexport function getPrometheusTimeRange(timeRange: AbsoluteTimeRange): { start: number; end: number } {\n  const { start, end } = timeRange;\n  return {\n    start: Math.ceil(getUnixTime(start)),\n    end: Math.ceil(getUnixTime(end)),\n  };\n}\n\n// Max data points to allow returning from a Prom Query, used to calculate a\n// \"safe\" step for a range query\nconst MAX_PROM_DATA_POINTS = 10000;\n\n/**\n * Gets the step to use for a Prom range query. Tries to take into account a suggested step size (probably based on the\n * width of a visualization where the data will be graphed), any minimum step/resolution set by the user, and a \"safe\"\n * step based on the max data points we want to allow returning from a Prom query.\n */\nexport function getRangeStep(\n  timeRange: PrometheusTimeRange,\n  minStepSeconds = 15,\n  resolution = 1,\n  suggestedStepMs = 0\n): number {\n  const suggestedStepSeconds = suggestedStepMs / 1000;\n  const queryRangeSeconds = timeRange.end - timeRange.start;\n\n  let safeStep = queryRangeSeconds / MAX_PROM_DATA_POINTS;\n  if (safeStep > 1) {\n    safeStep = Math.ceil(safeStep);\n  }\n\n  return Math.max(suggestedStepSeconds * resolution, minStepSeconds, safeStep);\n}\n\n/**\n * Converts a DurationString to seconds, rounding down.\n */\nexport function getDurationStringSeconds(durationString?: DurationString): number | undefined {\n  if (!durationString) return undefined;\n\n  const duration = parseDurationString(durationString);\n  const ms = milliseconds(duration);\n  return Math.floor(ms / 1000);\n}\n"],"names":["parseDurationString","milliseconds","getUnixTime","getPrometheusTimeRange","timeRange","start","end","Math","ceil","MAX_PROM_DATA_POINTS","getRangeStep","minStepSeconds","resolution","suggestedStepMs","suggestedStepSeconds","queryRangeSeconds","safeStep","max","getDurationStringSeconds","durationString","undefined","duration","ms","floor"],"mappings":"AAAA,oCAAoC;AACpC,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,6CAA6C;AAC7C,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;AAEjC,SAA4CA,mBAAmB,QAAQ,mBAAmB;AAC1F,SAASC,YAAY,EAAEC,WAAW,QAAQ,WAAW;AAQrD;;CAEC,GACD,OAAO,SAASC,uBAAuBC,SAA4B;IACjE,MAAM,EAAEC,KAAK,EAAEC,GAAG,EAAE,GAAGF;IACvB,OAAO;QACLC,OAAOE,KAAKC,IAAI,CAACN,YAAYG;QAC7BC,KAAKC,KAAKC,IAAI,CAACN,YAAYI;IAC7B;AACF;AAEA,4EAA4E;AAC5E,gCAAgC;AAChC,MAAMG,uBAAuB;AAE7B;;;;CAIC,GACD,OAAO,SAASC,aACdN,SAA8B,EAC9BO,iBAAiB,EAAE,EACnBC,aAAa,CAAC,EACdC,kBAAkB,CAAC;IAEnB,MAAMC,uBAAuBD,kBAAkB;IAC/C,MAAME,oBAAoBX,UAAUE,GAAG,GAAGF,UAAUC,KAAK;IAEzD,IAAIW,WAAWD,oBAAoBN;IACnC,IAAIO,WAAW,GAAG;QAChBA,WAAWT,KAAKC,IAAI,CAACQ;IACvB;IAEA,OAAOT,KAAKU,GAAG,CAACH,uBAAuBF,YAAYD,gBAAgBK;AACrE;AAEA;;CAEC,GACD,OAAO,SAASE,yBAAyBC,cAA+B;IACtE,IAAI,CAACA,gBAAgB,OAAOC;IAE5B,MAAMC,WAAWrB,oBAAoBmB;IACrC,MAAMG,KAAKrB,aAAaoB;IACxB,OAAOd,KAAKgB,KAAK,CAACD,KAAK;AACzB"}