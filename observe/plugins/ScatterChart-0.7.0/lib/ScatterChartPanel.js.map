{"version":3,"sources":["../../src/ScatterChartPanel.tsx"],"sourcesContent":["// Copyright 2023 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { PanelProps } from '@perses-dev/plugin-system';\nimport { ReactElement, useMemo } from 'react';\nimport { QueryDefinition, TraceData, TraceSearchResult } from '@perses-dev/core';\nimport { EChartsOption, SeriesOption } from 'echarts';\nimport { NoDataOverlay, useChartsTheme } from '@perses-dev/components';\nimport { Scatterplot } from './Scatterplot';\nimport { ScatterChartOptions } from './scatter-chart-model';\n\nexport interface EChartTraceValue extends Omit<TraceSearchResult, 'startTimeUnixMs' | 'serviceStats'> {\n  name: string;\n  query: QueryDefinition;\n  startTime: Date;\n  spanCount: number;\n  errorCount: number;\n}\n\nexport interface ScatterChartPanelProps extends PanelProps<ScatterChartOptions, TraceData> {\n  /**\n   * Custom onClick event handler.\n   * If this field is unset or undefined, a default handler which links to the Gantt chart on the explore page is configured.\n   * Set this field explicitly to null to disable handling the click event.\n   */\n  onClick?: ((data: EChartTraceValue) => void) | null;\n}\n\n/** default size range of the circles diameter */\nconst DEFAULT_SIZE_RANGE: [number, number] = [6, 20];\n\n// Navigate to the Gantt Chart on the explore page by default\nfunction defaultClickHandler(data: EChartTraceValue): void {\n  // clone the original query spec (including the datasource) and replace the query value with the trace id\n  const query: QueryDefinition = JSON.parse(JSON.stringify(data.query));\n  query.spec.plugin.spec.query = data.traceId;\n\n  const exploreParams = new URLSearchParams({\n    explorer: 'traces',\n    data: JSON.stringify({ queries: [query] }),\n  });\n\n  // do not use react-router here, as downstream products, which embed this panel, may not have a compatible version of it\n  window.location.href = `/explore?${exploreParams}`;\n}\n\n/**\n * ScatterChartPanel receives data from the DataQueriesProvider and transforms it\n * into a `dataset` object that Apache ECharts can consume. Additionally,\n * data formatting is also dictated in this component. Formatting includes\n * datapoint size and color.\n *\n * Documentation for data structures accepted by Apache ECharts:\n *  https://echarts.apache.org/handbook/en/concepts/dataset\n *\n * Examples for scatter chart formatting in Apache ECharts:\n *  https://echarts.apache.org/examples/en/index.html#chart-type-scatter\n *\n * @returns a `ScatterPlot` component that contains an EChart which will handle\n * visualization of the data.\n */\nexport function ScatterChartPanel(props: ScatterChartPanelProps): ReactElement | null {\n  const { spec, contentDimensions, queryResults: traceResults, onClick } = props;\n  const chartsTheme = useChartsTheme();\n  const defaultColor = chartsTheme.thresholds.defaultColor || 'blue';\n  const sizeRange = spec.sizeRange || DEFAULT_SIZE_RANGE;\n\n  // Generate dataset\n  // Transform Tempo API response to fit 'dataset' structure from Apache ECharts\n  // https://echarts.apache.org/handbook/en/concepts/dataset\n  const { dataset, minSpanCount, maxSpanCount } = useMemo(() => {\n    const dataset = [];\n    let minSpanCount: number | undefined;\n    let maxSpanCount: number | undefined;\n    for (const result of traceResults) {\n      if (result.data.searchResult === undefined) continue;\n      const dataSeries = result.data.searchResult.map((trace) => {\n        let spanCount = 0;\n        let errorCount = 0;\n        for (const stats of Object.values(trace.serviceStats)) {\n          spanCount += stats.spanCount;\n          errorCount += stats.errorCount ?? 0;\n        }\n\n        if (minSpanCount === undefined || spanCount < minSpanCount) {\n          minSpanCount = spanCount;\n        }\n        if (maxSpanCount === undefined || spanCount > maxSpanCount) {\n          maxSpanCount = spanCount;\n        }\n\n        const newTraceValue: EChartTraceValue = {\n          ...trace,\n          query: result.definition,\n          name: `${trace.rootServiceName}: ${trace.rootTraceName}`,\n          startTime: new Date(trace.startTimeUnixMs), // convert unix epoch time to Date\n          spanCount,\n          errorCount,\n        };\n        return newTraceValue;\n      });\n      dataset.push({\n        source: dataSeries,\n      });\n    }\n    return { dataset, minSpanCount: minSpanCount ?? 0, maxSpanCount: maxSpanCount ?? 0 };\n  }, [traceResults]);\n\n  // Formatting for the dataset\n  // 1. Map x,y coordinates\n  // 2. Datapoint size corresponds to the number of spans in a trace\n  // 3. Color datapoint red if the trace contains an error\n  const series = useMemo(() => {\n    const seriesTemplate2: SeriesOption = {\n      type: 'scatter',\n      encode: {\n        // Map to x-axis.\n        x: 'startTime',\n        // Map to y-axis.\n        y: 'durationMs',\n      },\n      symbolSize: function (data) {\n        // returns the diameter of the circles\n        return getSymbolSize(data.spanCount, [minSpanCount, maxSpanCount], sizeRange);\n      },\n      itemStyle: {\n        color: function (params) {\n          const traceData: EChartTraceValue = params.data as EChartTraceValue;\n          // If the trace contains an error, color the datapoint in red\n          if (traceData.errorCount > 0) {\n            return 'red';\n          }\n          // Else return default color\n          return defaultColor;\n        },\n      },\n    };\n\n    // Each data set needs to have a corresponding series formatting object\n    const series = [];\n    for (let i = 0; i < dataset.length; i++) {\n      series.push({ ...seriesTemplate2, datasetIndex: i });\n    }\n    return series;\n  }, [dataset, defaultColor, minSpanCount, maxSpanCount, sizeRange]);\n\n  const tracesFound = traceResults.some((traceData) => (traceData.data?.searchResult ?? []).length > 0);\n  if (!tracesFound) {\n    return <NoDataOverlay resource=\"traces\" />;\n  }\n\n  const options: EChartsOption = {\n    dataset: dataset,\n    series: series,\n  };\n\n  if (contentDimensions === undefined) return null;\n\n  return (\n    <div data-testid=\"ScatterChartPanel_ScatterPlot\">\n      <Scatterplot\n        width={contentDimensions.width}\n        height={contentDimensions.height}\n        options={options}\n        onClick={onClick === null ? undefined : (onClick ?? defaultClickHandler)}\n      />\n    </div>\n  );\n}\n\n// exported for tests\nexport function getSymbolSize(\n  spanCount: number,\n  spanCountRange: [number, number],\n  sizeRange: [number, number]\n): number {\n  const [minSize, maxSize] = sizeRange;\n  const [minSpanCount, maxSpanCount] = spanCountRange;\n\n  // catch divison by zero\n  if (maxSpanCount - minSpanCount === 0) {\n    return maxSize;\n  }\n\n  // apply linear scale of spanCount from range [minSpanCount,maxSpanCount] to a value from range [minSize,maxSize]\n  const rel = (spanCount - minSpanCount) / (maxSpanCount - minSpanCount);\n  return minSize + (maxSize - minSize) * rel;\n}\n"],"names":["useMemo","NoDataOverlay","useChartsTheme","Scatterplot","DEFAULT_SIZE_RANGE","defaultClickHandler","data","query","JSON","parse","stringify","spec","plugin","traceId","exploreParams","URLSearchParams","explorer","queries","window","location","href","ScatterChartPanel","props","contentDimensions","queryResults","traceResults","onClick","chartsTheme","defaultColor","thresholds","sizeRange","dataset","minSpanCount","maxSpanCount","result","searchResult","undefined","dataSeries","map","trace","spanCount","errorCount","stats","Object","values","serviceStats","newTraceValue","definition","name","rootServiceName","rootTraceName","startTime","Date","startTimeUnixMs","push","source","series","seriesTemplate2","type","encode","x","y","symbolSize","getSymbolSize","itemStyle","color","params","traceData","i","length","datasetIndex","tracesFound","some","resource","options","div","data-testid","width","height","spanCountRange","minSize","maxSize","rel"],"mappings":"AAAA,oCAAoC;AACpC,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,6CAA6C;AAC7C,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;AAGjC,SAAuBA,OAAO,QAAQ,QAAQ;AAG9C,SAASC,aAAa,EAAEC,cAAc,QAAQ,yBAAyB;AACvE,SAASC,WAAW,QAAQ,gBAAgB;AAoB5C,+CAA+C,GAC/C,MAAMC,qBAAuC;IAAC;IAAG;CAAG;AAEpD,6DAA6D;AAC7D,SAASC,oBAAoBC,IAAsB;IACjD,yGAAyG;IACzG,MAAMC,QAAyBC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACJ,KAAKC,KAAK;IACnEA,MAAMI,IAAI,CAACC,MAAM,CAACD,IAAI,CAACJ,KAAK,GAAGD,KAAKO,OAAO;IAE3C,MAAMC,gBAAgB,IAAIC,gBAAgB;QACxCC,UAAU;QACVV,MAAME,KAAKE,SAAS,CAAC;YAAEO,SAAS;gBAACV;aAAM;QAAC;IAC1C;IAEA,wHAAwH;IACxHW,OAAOC,QAAQ,CAACC,IAAI,GAAG,CAAC,SAAS,EAAEN,eAAe;AACpD;AAEA;;;;;;;;;;;;;;CAcC,GACD,OAAO,SAASO,kBAAkBC,KAA6B;IAC7D,MAAM,EAAEX,IAAI,EAAEY,iBAAiB,EAAEC,cAAcC,YAAY,EAAEC,OAAO,EAAE,GAAGJ;IACzE,MAAMK,cAAczB;IACpB,MAAM0B,eAAeD,YAAYE,UAAU,CAACD,YAAY,IAAI;IAC5D,MAAME,YAAYnB,KAAKmB,SAAS,IAAI1B;IAEpC,mBAAmB;IACnB,8EAA8E;IAC9E,0DAA0D;IAC1D,MAAM,EAAE2B,OAAO,EAAEC,YAAY,EAAEC,YAAY,EAAE,GAAGjC,QAAQ;QACtD,MAAM+B,UAAU,EAAE;QAClB,IAAIC;QACJ,IAAIC;QACJ,KAAK,MAAMC,UAAUT,aAAc;YACjC,IAAIS,OAAO5B,IAAI,CAAC6B,YAAY,KAAKC,WAAW;YAC5C,MAAMC,aAAaH,OAAO5B,IAAI,CAAC6B,YAAY,CAACG,GAAG,CAAC,CAACC;gBAC/C,IAAIC,YAAY;gBAChB,IAAIC,aAAa;gBACjB,KAAK,MAAMC,SAASC,OAAOC,MAAM,CAACL,MAAMM,YAAY,EAAG;oBACrDL,aAAaE,MAAMF,SAAS;oBAC5BC,cAAcC,MAAMD,UAAU,IAAI;gBACpC;gBAEA,IAAIT,iBAAiBI,aAAaI,YAAYR,cAAc;oBAC1DA,eAAeQ;gBACjB;gBACA,IAAIP,iBAAiBG,aAAaI,YAAYP,cAAc;oBAC1DA,eAAeO;gBACjB;gBAEA,MAAMM,gBAAkC;oBACtC,GAAGP,KAAK;oBACRhC,OAAO2B,OAAOa,UAAU;oBACxBC,MAAM,GAAGT,MAAMU,eAAe,CAAC,EAAE,EAAEV,MAAMW,aAAa,EAAE;oBACxDC,WAAW,IAAIC,KAAKb,MAAMc,eAAe;oBACzCb;oBACAC;gBACF;gBACA,OAAOK;YACT;YACAf,QAAQuB,IAAI,CAAC;gBACXC,QAAQlB;YACV;QACF;QACA,OAAO;YAAEN;YAASC,cAAcA,gBAAgB;YAAGC,cAAcA,gBAAgB;QAAE;IACrF,GAAG;QAACR;KAAa;IAEjB,6BAA6B;IAC7B,yBAAyB;IACzB,kEAAkE;IAClE,wDAAwD;IACxD,MAAM+B,SAASxD,QAAQ;QACrB,MAAMyD,kBAAgC;YACpCC,MAAM;YACNC,QAAQ;gBACN,iBAAiB;gBACjBC,GAAG;gBACH,iBAAiB;gBACjBC,GAAG;YACL;YACAC,YAAY,SAAUxD,IAAI;gBACxB,sCAAsC;gBACtC,OAAOyD,cAAczD,KAAKkC,SAAS,EAAE;oBAACR;oBAAcC;iBAAa,EAAEH;YACrE;YACAkC,WAAW;gBACTC,OAAO,SAAUC,MAAM;oBACrB,MAAMC,YAA8BD,OAAO5D,IAAI;oBAC/C,6DAA6D;oBAC7D,IAAI6D,UAAU1B,UAAU,GAAG,GAAG;wBAC5B,OAAO;oBACT;oBACA,4BAA4B;oBAC5B,OAAOb;gBACT;YACF;QACF;QAEA,uEAAuE;QACvE,MAAM4B,SAAS,EAAE;QACjB,IAAK,IAAIY,IAAI,GAAGA,IAAIrC,QAAQsC,MAAM,EAAED,IAAK;YACvCZ,OAAOF,IAAI,CAAC;gBAAE,GAAGG,eAAe;gBAAEa,cAAcF;YAAE;QACpD;QACA,OAAOZ;IACT,GAAG;QAACzB;QAASH;QAAcI;QAAcC;QAAcH;KAAU;IAEjE,MAAMyC,cAAc9C,aAAa+C,IAAI,CAAC,CAACL,YAAc,AAACA,CAAAA,UAAU7D,IAAI,EAAE6B,gBAAgB,EAAE,AAAD,EAAGkC,MAAM,GAAG;IACnG,IAAI,CAACE,aAAa;QAChB,qBAAO,KAACtE;YAAcwE,UAAS;;IACjC;IAEA,MAAMC,UAAyB;QAC7B3C,SAASA;QACTyB,QAAQA;IACV;IAEA,IAAIjC,sBAAsBa,WAAW,OAAO;IAE5C,qBACE,KAACuC;QAAIC,eAAY;kBACf,cAAA,KAACzE;YACC0E,OAAOtD,kBAAkBsD,KAAK;YAC9BC,QAAQvD,kBAAkBuD,MAAM;YAChCJ,SAASA;YACThD,SAASA,YAAY,OAAOU,YAAaV,WAAWrB;;;AAI5D;AAEA,qBAAqB;AACrB,OAAO,SAAS0D,cACdvB,SAAiB,EACjBuC,cAAgC,EAChCjD,SAA2B;IAE3B,MAAM,CAACkD,SAASC,QAAQ,GAAGnD;IAC3B,MAAM,CAACE,cAAcC,aAAa,GAAG8C;IAErC,wBAAwB;IACxB,IAAI9C,eAAeD,iBAAiB,GAAG;QACrC,OAAOiD;IACT;IAEA,iHAAiH;IACjH,MAAMC,MAAM,AAAC1C,CAAAA,YAAYR,YAAW,IAAMC,CAAAA,eAAeD,YAAW;IACpE,OAAOgD,UAAU,AAACC,CAAAA,UAAUD,OAAM,IAAKE;AACzC"}