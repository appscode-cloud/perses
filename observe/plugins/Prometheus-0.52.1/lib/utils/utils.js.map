{"version":3,"sources":["../../../src/utils/utils.ts"],"sourcesContent":["// Copyright 2023 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Metric } from '../model/api-types';\n\n/**\n * Types for metric labels, used in seriesNameFormat implementation\n */\nexport type SeriesLabels = Record<string, string>;\n\n/*\n * Formatter used for series name display in legends and tooltips.\n * Regex replaces label {{ name }} with resolved label value.\n * If no resolved value, return empty string instead of the token inside double curly braces.\n */\nexport function formatSeriesName(inputFormat: string, seriesLabels: SeriesLabels): string {\n  const resolveLabelsRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return inputFormat.replace(resolveLabelsRegex, (_match, token) => {\n    const resolvedValue = seriesLabels[token] ?? '';\n    return resolvedValue;\n  });\n}\n\n/*\n * Stringifies object of labels into valid PromQL for querying metric by label\n */\nfunction stringifyPrometheusMetricLabels(labels: { [key: string]: unknown }, removeExprWrap?: boolean): string {\n  const labelStrings: string[] = [];\n  Object.keys(labels)\n    .sort()\n    .forEach((labelName) => {\n      const labelValue = labels[labelName];\n      if (labelValue !== undefined) {\n        if (removeExprWrap) {\n          labelStrings.push(`\"${labelName}\":\"${labelValue}\"`);\n        } else {\n          labelStrings.push(`${labelName}=\"${labelValue}\"`);\n        }\n      }\n    });\n  return `{${labelStrings.join(',')}}`;\n}\n\n/*\n * Metric labels formatter which checks for __name__ and outputs valid PromQL for series name\n */\nexport function getUniqueKeyForPrometheusResult(\n  metricLabels: {\n    [key: string]: string;\n  },\n  { removeExprWrap }: { removeExprWrap?: boolean } = {}\n): string {\n  const metricNameKey = '__name__';\n  if (Object.prototype.hasOwnProperty.call(metricLabels, metricNameKey)) {\n    const stringifiedLabels = stringifyPrometheusMetricLabels(\n      {\n        ...metricLabels,\n        [metricNameKey]: undefined,\n      },\n      removeExprWrap\n    );\n    if (removeExprWrap) {\n      return `${stringifiedLabels}`;\n    } else {\n      return `${metricLabels[metricNameKey]}${stringifiedLabels}`;\n    }\n  }\n  return stringifyPrometheusMetricLabels(metricLabels, removeExprWrap);\n}\n\n/*\n * Determine human-readable series name to be used in legend and tooltip\n */\nexport function getFormattedPrometheusSeriesName(\n  query: string,\n  metric: Metric,\n  formatter?: string\n): {\n  name: string;\n  formattedName: string;\n} {\n  // Name the series after the metric labels by default.\n  const name = getUniqueKeyForPrometheusResult(metric);\n\n  // Query editor allows you to define an optional seriesNameFormat property.\n  // This controls the regex used to customize legend and tooltip display.\n  const formattedName = formatter ? formatSeriesName(formatter, metric) : name;\n  return { name, formattedName };\n}\n"],"names":["formatSeriesName","inputFormat","seriesLabels","resolveLabelsRegex","replace","_match","token","resolvedValue","stringifyPrometheusMetricLabels","labels","removeExprWrap","labelStrings","Object","keys","sort","forEach","labelName","labelValue","undefined","push","join","getUniqueKeyForPrometheusResult","metricLabels","metricNameKey","prototype","hasOwnProperty","call","stringifiedLabels","getFormattedPrometheusSeriesName","query","metric","formatter","name","formattedName"],"mappings":"AAAA,oCAAoC;AACpC,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,6CAA6C;AAC7C,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;AASjC;;;;CAIC,GACD,OAAO,SAASA,iBAAiBC,WAAmB,EAAEC,YAA0B;IAC9E,MAAMC,qBAAqB;IAC3B,OAAOF,YAAYG,OAAO,CAACD,oBAAoB,CAACE,QAAQC;QACtD,MAAMC,gBAAgBL,YAAY,CAACI,MAAM,IAAI;QAC7C,OAAOC;IACT;AACF;AAEA;;CAEC,GACD,SAASC,gCAAgCC,MAAkC,EAAEC,cAAwB;IACnG,MAAMC,eAAyB,EAAE;IACjCC,OAAOC,IAAI,CAACJ,QACTK,IAAI,GACJC,OAAO,CAAC,CAACC;QACR,MAAMC,aAAaR,MAAM,CAACO,UAAU;QACpC,IAAIC,eAAeC,WAAW;YAC5B,IAAIR,gBAAgB;gBAClBC,aAAaQ,IAAI,CAAC,CAAC,CAAC,EAAEH,UAAU,GAAG,EAAEC,WAAW,CAAC,CAAC;YACpD,OAAO;gBACLN,aAAaQ,IAAI,CAAC,GAAGH,UAAU,EAAE,EAAEC,WAAW,CAAC,CAAC;YAClD;QACF;IACF;IACF,OAAO,CAAC,CAAC,EAAEN,aAAaS,IAAI,CAAC,KAAK,CAAC,CAAC;AACtC;AAEA;;CAEC,GACD,OAAO,SAASC,gCACdC,YAEC,EACD,EAAEZ,cAAc,EAAgC,GAAG,CAAC,CAAC;IAErD,MAAMa,gBAAgB;IACtB,IAAIX,OAAOY,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,cAAcC,gBAAgB;QACrE,MAAMI,oBAAoBnB,gCACxB;YACE,GAAGc,YAAY;YACf,CAACC,cAAc,EAAEL;QACnB,GACAR;QAEF,IAAIA,gBAAgB;YAClB,OAAO,GAAGiB,mBAAmB;QAC/B,OAAO;YACL,OAAO,GAAGL,YAAY,CAACC,cAAc,GAAGI,mBAAmB;QAC7D;IACF;IACA,OAAOnB,gCAAgCc,cAAcZ;AACvD;AAEA;;CAEC,GACD,OAAO,SAASkB,iCACdC,KAAa,EACbC,MAAc,EACdC,SAAkB;IAKlB,sDAAsD;IACtD,MAAMC,OAAOX,gCAAgCS;IAE7C,2EAA2E;IAC3E,wEAAwE;IACxE,MAAMG,gBAAgBF,YAAY/B,iBAAiB+B,WAAWD,UAAUE;IACxE,OAAO;QAAEA;QAAMC;IAAc;AAC/B"}