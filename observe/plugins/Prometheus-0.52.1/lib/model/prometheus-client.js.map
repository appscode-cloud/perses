{"version":3,"sources":["../../../src/model/prometheus-client.ts"],"sourcesContent":["// Copyright 2023 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { fetch, fetchJson, RequestHeaders } from '@perses-dev/core';\nimport { DatasourceClient } from '@perses-dev/plugin-system';\nimport {\n  InstantQueryRequestParameters,\n  InstantQueryResponse,\n  LabelNamesRequestParameters,\n  LabelNamesResponse,\n  LabelValuesRequestParameters,\n  LabelValuesResponse,\n  MetricMetadataRequestParameters,\n  MetricMetadataResponse,\n  ParseQueryRequestParameters,\n  ParseQueryResponse,\n  RangeQueryRequestParameters,\n  RangeQueryResponse,\n  SeriesRequestParameters,\n  SeriesResponse,\n  SuccessResponse,\n} from './api-types';\n\ninterface PrometheusClientOptions {\n  datasourceUrl: string;\n  headers?: RequestHeaders;\n}\n\nexport interface PrometheusClient extends DatasourceClient {\n  options: PrometheusClientOptions;\n  instantQuery(params: InstantQueryRequestParameters, headers?: RequestHeaders): Promise<InstantQueryResponse>;\n  rangeQuery(params: RangeQueryRequestParameters, headers?: RequestHeaders): Promise<RangeQueryResponse>;\n  labelNames(params: LabelNamesRequestParameters, headers?: RequestHeaders): Promise<LabelNamesResponse>;\n  labelValues(params: LabelValuesRequestParameters, headers?: RequestHeaders): Promise<LabelValuesResponse>;\n  metricMetadata(params: MetricMetadataRequestParameters, headers?: RequestHeaders): Promise<MetricMetadataResponse>;\n  series(params: SeriesRequestParameters, headers?: RequestHeaders): Promise<SeriesResponse>;\n  parseQuery(params: ParseQueryRequestParameters, headers?: RequestHeaders): Promise<ParseQueryResponse>;\n}\n\nexport interface QueryOptions {\n  datasourceUrl: string;\n  headers?: RequestHeaders;\n}\n\n/**\n * Calls the `/-/healthy` endpoint to check if the datasource is healthy.\n */\nexport function healthCheck(queryOptions: QueryOptions) {\n  return async (): Promise<boolean> => {\n    const url = `${queryOptions.datasourceUrl}/-/healthy`;\n\n    try {\n      const resp = await fetch(url, { headers: queryOptions.headers });\n      return resp.status === 200;\n    } catch {\n      return false;\n    }\n  };\n}\n\n/**\n * Calls the `/api/v1/query` endpoint to get metrics data.\n */\nexport function instantQuery(\n  params: InstantQueryRequestParameters,\n  queryOptions: QueryOptions\n): Promise<InstantQueryResponse> {\n  return fetchWithPost<InstantQueryRequestParameters, InstantQueryResponse>('/api/v1/query', params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/query_range` endpoint to get metrics data.\n */\nexport function rangeQuery(\n  params: RangeQueryRequestParameters,\n  queryOptions: QueryOptions\n): Promise<RangeQueryResponse> {\n  return fetchWithPost<RangeQueryRequestParameters, RangeQueryResponse>('/api/v1/query_range', params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/labels` endpoint to get a list of label names.\n */\nexport function labelNames(\n  params: LabelNamesRequestParameters,\n  queryOptions: QueryOptions\n): Promise<LabelNamesResponse> {\n  return fetchWithPost<LabelNamesRequestParameters, LabelNamesResponse>('/api/v1/labels', params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/label/{labelName}/values` endpoint to get a list of values for a label.\n */\nexport function labelValues(\n  params: LabelValuesRequestParameters,\n  queryOptions: QueryOptions\n): Promise<LabelValuesResponse> {\n  const { labelName, ...searchParams } = params;\n\n  // In case label name is empty, we'll receive a 404, so we can replace it by an empty list, which is less confusing.\n  // Note that an empty list is the prometheus result if the label does not exist.\n  if (labelName.length === 0) {\n    return new Promise((resolve) => {\n      resolve({ data: [] as string[] } as SuccessResponse<string[]>);\n    });\n  }\n\n  const apiURI = `/api/v1/label/${encodeURIComponent(labelName)}/values`;\n  return fetchWithGet<typeof searchParams, LabelValuesResponse>(apiURI, searchParams, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/label/{labelName}/values` endpoint to get a list of values for a label.\n */\nexport function metricMetadata(\n  params: MetricMetadataRequestParameters,\n  queryOptions: QueryOptions\n): Promise<MetricMetadataResponse> {\n  const apiURI = `/api/v1/metadata`;\n  return fetchWithGet<MetricMetadataRequestParameters, MetricMetadataResponse>(apiURI, params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/series` endpoint to finding series by label matchers.\n */\nexport function series(params: SeriesRequestParameters, queryOptions: QueryOptions): Promise<SeriesResponse> {\n  const apiURI = `/api/v1/series`;\n  return fetchWithPost<SeriesRequestParameters, SeriesResponse>(apiURI, params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/parse_query` to parse the given promQL expresion into an abstract syntax tree (AST).\n */\nexport function parseQuery(\n  params: ParseQueryRequestParameters,\n  queryOptions: QueryOptions\n): Promise<ParseQueryResponse> {\n  const apiURI = `/api/v1/parse_query`;\n  return fetchWithPost<ParseQueryRequestParameters, ParseQueryResponse>(apiURI, params, queryOptions);\n}\n\nfunction fetchWithGet<T extends RequestParams<T>, TResponse>(\n  apiURI: string,\n  params: T,\n  queryOptions: QueryOptions\n): Promise<TResponse> {\n  const { datasourceUrl, headers } = queryOptions;\n\n  let url = `${datasourceUrl}${apiURI}`;\n  const urlParams = createSearchParams(params).toString();\n  if (urlParams !== '') {\n    url += `?${urlParams}`;\n  }\n  return fetchJson<TResponse>(url, { method: 'GET', headers });\n}\n\nfunction fetchWithPost<T extends RequestParams<T>, TResponse>(\n  apiURI: string,\n  params: T,\n  queryOptions: QueryOptions\n): Promise<TResponse> {\n  const { datasourceUrl, headers } = queryOptions;\n\n  const url = `${datasourceUrl}${apiURI}`;\n  const init = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      ...headers,\n    },\n    body: createSearchParams(params),\n  };\n  return fetchResults<TResponse>(url, init);\n}\n\n// Request parameter values we know how to serialize\ntype ParamValue = string | string[] | number | undefined;\n\n// Used to constrain the types that can be passed to createSearchParams to\n// just the ones we know how to serialize\ntype RequestParams<T> = {\n  [K in keyof T]: ParamValue;\n};\n\n/**\n * Creates URLSearchParams from a request params object.\n */\nfunction createSearchParams<T extends RequestParams<T>>(params: T): URLSearchParams {\n  const searchParams = new URLSearchParams();\n  for (const key in params) {\n    const value: ParamValue = params[key];\n    if (value === undefined) continue;\n\n    if (typeof value === 'string') {\n      searchParams.append(key, value);\n      continue;\n    }\n\n    if (typeof value === 'number') {\n      searchParams.append(key, value.toString());\n      continue;\n    }\n\n    for (const val of value) {\n      searchParams.append(key, val);\n    }\n  }\n  return searchParams;\n}\n\n/**\n * Fetch JSON and parse warnings for query inspector\n */\nexport async function fetchResults<T>(...args: Parameters<typeof global.fetch>): Promise<T> {\n  const response = await fetch(...args);\n  const json: T = await response.json();\n  return { ...json, rawResponse: response };\n}\n"],"names":["fetch","fetchJson","healthCheck","queryOptions","url","datasourceUrl","resp","headers","status","instantQuery","params","fetchWithPost","rangeQuery","labelNames","labelValues","labelName","searchParams","length","Promise","resolve","data","apiURI","encodeURIComponent","fetchWithGet","metricMetadata","series","parseQuery","urlParams","createSearchParams","toString","method","init","body","fetchResults","URLSearchParams","key","value","undefined","append","val","args","response","json","rawResponse"],"mappings":"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"}