{"version":3,"sources":["../../../../src/components/promql/ast.ts"],"sourcesContent":["// Copyright 2024 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Forked from https://github.com/prometheus/prometheus/blob/65f610353919b1c7b42d3776c3a95b68046a6bba/web/ui/mantine-ui/src/promql/ast.ts\n\nexport enum nodeType {\n  aggregation = 'aggregation',\n  binaryExpr = 'binaryExpr',\n  call = 'call',\n  matrixSelector = 'matrixSelector',\n  subquery = 'subquery',\n  numberLiteral = 'numberLiteral',\n  parenExpr = 'parenExpr',\n  stringLiteral = 'stringLiteral',\n  unaryExpr = 'unaryExpr',\n  vectorSelector = 'vectorSelector',\n  placeholder = 'placeholder',\n}\n\nexport enum aggregationType {\n  sum = 'sum',\n  min = 'min',\n  max = 'max',\n  avg = 'avg',\n  stddev = 'stddev',\n  stdvar = 'stdvar',\n  count = 'count',\n  group = 'group',\n  countValues = 'count_values',\n  bottomk = 'bottomk',\n  topk = 'topk',\n  quantile = 'quantile',\n  limitK = 'limitk',\n  limitRatio = 'limit_ratio',\n}\n\nexport enum binaryOperatorType {\n  add = '+',\n  sub = '-',\n  mul = '*',\n  div = '/',\n  mod = '%',\n  pow = '^',\n  eql = '==',\n  neq = '!=',\n  gtr = '>',\n  lss = '<',\n  gte = '>=',\n  lte = '<=',\n  and = 'and',\n  or = 'or',\n  unless = 'unless',\n  atan2 = 'atan2',\n}\n\nexport const compOperatorTypes: binaryOperatorType[] = [\n  binaryOperatorType.eql,\n  binaryOperatorType.neq,\n  binaryOperatorType.gtr,\n  binaryOperatorType.lss,\n  binaryOperatorType.gte,\n  binaryOperatorType.lte,\n];\n\nexport const setOperatorTypes: binaryOperatorType[] = [\n  binaryOperatorType.and,\n  binaryOperatorType.or,\n  binaryOperatorType.unless,\n];\n\nexport enum unaryOperatorType {\n  plus = '+',\n  minus = '-',\n}\n\nexport enum vectorMatchCardinality {\n  oneToOne = 'one-to-one',\n  manyToOne = 'many-to-one',\n  oneToMany = 'one-to-many',\n  manyToMany = 'many-to-many',\n}\n\nexport enum valueType {\n  // TODO: 'none' should never make it out of Prometheus. Do we need this here?\n  none = 'none',\n  vector = 'vector',\n  scalar = 'scalar',\n  matrix = 'matrix',\n  string = 'string',\n}\n\nexport enum matchType {\n  equal = '=',\n  notEqual = '!=',\n  matchRegexp = '=~',\n  matchNotRegexp = '!~',\n}\n\nexport interface Func {\n  name: string;\n  argTypes: valueType[];\n  variadic: number;\n  returnType: valueType;\n}\n\nexport interface LabelMatcher {\n  type: matchType;\n  name: string;\n  value: string;\n}\n\nexport interface VectorMatching {\n  card: vectorMatchCardinality;\n  labels: string[];\n  on: boolean;\n  include: string[];\n}\n\nexport type StartOrEnd = 'start' | 'end' | null;\n\n// AST Node Types.\n\nexport interface Aggregation {\n  type: nodeType.aggregation;\n  expr: ASTNode;\n  op: aggregationType;\n  param: ASTNode | null;\n  grouping: string[];\n  without: boolean;\n}\n\nexport interface BinaryExpr {\n  type: nodeType.binaryExpr;\n  op: binaryOperatorType;\n  lhs: ASTNode;\n  rhs: ASTNode;\n  matching: VectorMatching | null;\n  bool: boolean;\n}\n\nexport interface Call {\n  type: nodeType.call;\n  func: Func;\n  args: ASTNode[];\n}\n\nexport interface MatrixSelector {\n  type: nodeType.matrixSelector;\n  name: string;\n  matchers: LabelMatcher[];\n  range: number;\n  offset: number;\n  timestamp: number | null;\n  startOrEnd: StartOrEnd;\n}\n\nexport interface Subquery {\n  type: nodeType.subquery;\n  expr: ASTNode;\n  range: number;\n  offset: number;\n  step: number;\n  timestamp: number | null;\n  startOrEnd: StartOrEnd;\n}\n\nexport interface NumberLiteral {\n  type: nodeType.numberLiteral;\n  val: string; // Can't be 'number' because JS doesn't support NaN/Inf/-Inf etc.\n}\n\nexport interface ParenExpr {\n  type: nodeType.parenExpr;\n  expr: ASTNode;\n}\n\nexport interface StringLiteral {\n  type: nodeType.stringLiteral;\n  val: string;\n}\n\nexport interface UnaryExpr {\n  type: nodeType.unaryExpr;\n  op: unaryOperatorType;\n  expr: ASTNode;\n}\n\nexport interface VectorSelector {\n  type: nodeType.vectorSelector;\n  name: string;\n  matchers: LabelMatcher[];\n  offset: number;\n  timestamp: number | null;\n  startOrEnd: StartOrEnd;\n}\n\nexport interface Placeholder {\n  type: nodeType.placeholder;\n  children: ASTNode[];\n}\n\n// NB: AST stands for Abstract Syntax Tree\ntype ASTNode =\n  | Aggregation\n  | BinaryExpr\n  | Call\n  | MatrixSelector\n  | Subquery\n  | NumberLiteral\n  | ParenExpr\n  | StringLiteral\n  | UnaryExpr\n  | VectorSelector\n  | Placeholder;\n\nexport default ASTNode;\n"],"names":["nodeType","aggregationType","binaryOperatorType","compOperatorTypes","setOperatorTypes","unaryOperatorType","vectorMatchCardinality","valueType","matchType"],"mappings":"AAAA,oCAAoC;AACpC,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,6CAA6C;AAC7C,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;AAEjC,yIAAyI;AAEzI,OAAO,IAAA,AAAKA,kCAAAA;;;;;;;;;;;;WAAAA;MAYX;AAED,OAAO,IAAA,AAAKC,yCAAAA;;;;;;;;;;;;;;;WAAAA;MAeX;AAED,OAAO,IAAA,AAAKC,4CAAAA;;;;;;;;;;;;;;;;;WAAAA;MAiBX;AAED,OAAO,MAAMC,oBAA0C;;;;;;;CAOtD,CAAC;AAEF,OAAO,MAAMC,mBAAyC;;;;CAIrD,CAAC;AAEF,OAAO,IAAA,AAAKC,2CAAAA;;;WAAAA;MAGX;AAED,OAAO,IAAA,AAAKC,gDAAAA;;;;;WAAAA;MAKX;AAED,OAAO,IAAA,AAAKC,mCAAAA;IACV,6EAA6E;;;;;;WADnEA;MAOX;AAED,OAAO,IAAA,AAAKC,mCAAAA;;;;;WAAAA;MAKX"}