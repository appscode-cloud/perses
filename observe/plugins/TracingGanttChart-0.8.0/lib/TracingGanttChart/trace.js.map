{"version":3,"sources":["../../../src/TracingGanttChart/trace.ts"],"sourcesContent":["// Copyright 2024 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { otlpcommonv1, otlpresourcev1, otlptracev1 } from '@perses-dev/core';\nimport { sortedIndexBy } from 'lodash';\n\n/** holds the trace and computed properties required for the Gantt chart */\nexport interface Trace {\n  trace: otlptracev1.TracesData;\n\n  /**\n   * if a trace is incomplete (e.g. a parent span has not been received yet),\n   * this branch of the span tree will be appended to the root\n   */\n  rootSpans: Span[];\n  startTimeUnixMs: number;\n  endTimeUnixMs: number;\n}\n\nexport interface Span {\n  resource: Resource;\n  scope: otlpcommonv1.InstrumentationScope;\n  parentSpan?: Span;\n  /** child spans, sorted by startTime */\n  childSpans: Span[];\n\n  traceId: string;\n  spanId: string;\n  parentSpanId?: string;\n  name: string;\n  kind?: string;\n  startTimeUnixMs: number;\n  endTimeUnixMs: number;\n  attributes: otlpcommonv1.KeyValue[];\n  events: Event[];\n  status: otlptracev1.Status;\n}\n\nexport interface Resource {\n  serviceName?: string;\n  attributes: otlpcommonv1.KeyValue[];\n}\n\nexport interface Event {\n  timeUnixMs: number;\n  name: string;\n  attributes: otlpcommonv1.KeyValue[];\n}\n\n/**\n * getTraceModel builds a tree of spans from an OTLP trace,\n * and precomputes common fields, for example the start and end time of a trace.\n * Time complexity: O(2n)\n */\nexport function getTraceModel(trace: otlptracev1.TracesData): Trace {\n  // first pass: build lookup table <spanId, Span> and compute min/max\n  const lookup = new Map<string, Span>();\n  const rootSpans: Span[] = [];\n  let startTimeUnixMs: number = 0;\n  let endTimeUnixMs: number = 0;\n  for (const resourceSpan of trace.resourceSpans) {\n    const resource = parseResource(resourceSpan.resource);\n\n    for (const scopeSpan of resourceSpan.scopeSpans) {\n      const scope = parseScope(scopeSpan.scope);\n\n      for (const otelSpan of scopeSpan.spans) {\n        const span: Span = {\n          resource,\n          scope,\n          childSpans: [],\n          ...parseSpan(otelSpan),\n        };\n        lookup.set(otelSpan.spanId, span);\n\n        if (startTimeUnixMs === 0 || span.startTimeUnixMs < startTimeUnixMs) {\n          startTimeUnixMs = span.startTimeUnixMs;\n        }\n        if (endTimeUnixMs === 0 || span.endTimeUnixMs > endTimeUnixMs) {\n          endTimeUnixMs = span.endTimeUnixMs;\n        }\n      }\n    }\n  }\n\n  // second pass: build tree based on parentSpanId property\n  for (const [, span] of lookup) {\n    if (!span.parentSpanId) {\n      rootSpans.push(span);\n      continue;\n    }\n\n    const parent = lookup.get(span.parentSpanId);\n    if (!parent) {\n      console.trace(`span ${span.spanId} has parent ${span.parentSpanId} which has not been received yet`);\n      rootSpans.push(span);\n      continue;\n    }\n\n    span.parentSpan = parent;\n    const insertChildSpanAt = sortedIndexBy(parent.childSpans, span, (s) => s.startTimeUnixMs);\n    parent.childSpans.splice(insertChildSpanAt, 0, span);\n  }\n\n  return { trace, rootSpans, startTimeUnixMs, endTimeUnixMs };\n}\n\nfunction parseResource(resource?: otlpresourcev1.Resource): Resource {\n  let serviceName = 'unknown';\n  for (const attr of resource?.attributes ?? []) {\n    if (attr.key === 'service.name' && 'stringValue' in attr.value) {\n      serviceName = attr.value.stringValue;\n      break;\n    }\n  }\n\n  return {\n    serviceName,\n    attributes: resource?.attributes ?? [],\n  };\n}\n\nfunction parseScope(scope?: otlpcommonv1.InstrumentationScope): otlpcommonv1.InstrumentationScope {\n  return scope ?? {};\n}\n\n/**\n * parseSpan parses the Span API type to the internal representation\n * i.e. convert strings to numbers etc.\n */\nfunction parseSpan(span: otlptracev1.Span): Omit<Span, 'resource' | 'scope' | 'childSpans'> {\n  return {\n    traceId: span.traceId,\n    spanId: span.spanId,\n    parentSpanId: span.parentSpanId,\n    name: span.name,\n    kind: span.kind,\n    startTimeUnixMs: parseInt(span.startTimeUnixNano) * 1e-6, // convert to milliseconds because JS cannot handle numbers larger than 9007199254740991\n    endTimeUnixMs: parseInt(span.endTimeUnixNano) * 1e-6,\n    attributes: span.attributes ?? [],\n    events: (span.events ?? []).map(parseEvent),\n    status: span.status ?? {},\n  };\n}\n\nfunction parseEvent(event: otlptracev1.Event): Event {\n  return {\n    timeUnixMs: parseInt(event.timeUnixNano) * 1e-6, // convert to milliseconds because JS cannot handle numbers larger than 9007199254740991\n    name: event.name,\n    attributes: event.attributes ?? [],\n  };\n}\n"],"names":["sortedIndexBy","getTraceModel","trace","lookup","Map","rootSpans","startTimeUnixMs","endTimeUnixMs","resourceSpan","resourceSpans","resource","parseResource","scopeSpan","scopeSpans","scope","parseScope","otelSpan","spans","span","childSpans","parseSpan","set","spanId","parentSpanId","push","parent","get","console","parentSpan","insertChildSpanAt","s","splice","serviceName","attr","attributes","key","value","stringValue","traceId","name","kind","parseInt","startTimeUnixNano","endTimeUnixNano","events","map","parseEvent","status","event","timeUnixMs","timeUnixNano"],"mappings":"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"}