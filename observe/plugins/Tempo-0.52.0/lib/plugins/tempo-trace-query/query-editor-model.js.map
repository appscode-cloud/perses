{"version":3,"sources":["../../../../src/plugins/tempo-trace-query/query-editor-model.ts"],"sourcesContent":["// Copyright 2025 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { useState } from 'react';\nimport { produce } from 'immer';\nimport { OptionsEditorProps } from '@perses-dev/plugin-system';\nimport { TempoTraceQuerySpec } from '../../model/trace-query-model';\n\nexport type TraceQueryEditorProps = OptionsEditorProps<TempoTraceQuerySpec>;\n\n/**\n * A hook for managing the `query` state in PrometheusTimeSeriesQuerySpec. Returns the `query` value, along with\n * `onChange` and `onBlur` event handlers to the input. Keeps a local copy of the user's input and only syncs those\n * changes with the overall spec value once the input is blurred to prevent re-running queries in the panel's preview\n * every time the user types.\n */\nexport function useQueryState(props: TraceQueryEditorProps): {\n  query: string;\n  handleQueryChange: (e: string) => void;\n  handleQueryBlur: () => void;\n} {\n  const { onChange, value } = props;\n\n  // Local copy of the query's value\n  const [query, setQuery] = useState(value.query);\n\n  // This is basically \"getDerivedStateFromProps\" to make sure if spec's value changes external to this component,\n  // we render with the latest value\n  const [lastSyncedQuery, setLastSyncedQuery] = useState(value.query);\n  if (value.query !== lastSyncedQuery) {\n    setQuery(value.query);\n    setLastSyncedQuery(value.query);\n  }\n\n  // Update our local state's copy as the user types\n  const handleQueryChange = (e: string): void => {\n    setQuery(e);\n  };\n\n  // Propagate changes to the query's value when the input is blurred to avoid constantly re-running queries in the\n  // PanelPreview\n  const handleQueryBlur = (): void => {\n    setLastSyncedQuery(query);\n    onChange(\n      produce(value, (draft) => {\n        draft.query = query;\n      })\n    );\n  };\n\n  return { query, handleQueryChange, handleQueryBlur };\n}\n\n/**\n * Hook to manage `limit` state to ensure panel preview does not rerender until text input is blurred\n */\nexport function useLimitState(props: TraceQueryEditorProps): {\n  limit: string;\n  handleLimitChange: (e: string) => void;\n  handleLimitBlur: () => void;\n  limitHasError: boolean;\n} {\n  const { onChange, value } = props;\n\n  // TODO: reusable hook or helper util instead of duplicating from useQueryState\n  const [limit, setLimit] = useState(value.limit ? value.limit.toString() : '');\n  const [lastSyncedLimit, setLastSyncedLimit] = useState(value.limit);\n  if (value.limit !== lastSyncedLimit) {\n    setLimit(value.limit ? value.limit.toString() : '');\n    setLastSyncedLimit(value.limit);\n  }\n\n  // limit must be empty or an integer > 0\n  const limitHasError = !(limit === '' || (/^[0-9]+$/.test(limit) && parseInt(limit) > 0));\n\n  // Update our local state as the user types\n  const handleLimitChange = (e: string): void => {\n    setLimit(e);\n  };\n\n  // Propagate changes to the panel preview component when limit TextField is blurred\n  const handleLimitBlur = (): void => {\n    if (limitHasError) {\n      return;\n    }\n\n    const limitVal = limit === '' ? undefined : parseInt(limit);\n    setLastSyncedLimit(limitVal);\n    onChange(\n      produce(value, (draft) => {\n        draft.limit = limitVal;\n      })\n    );\n  };\n\n  return { limit, handleLimitChange, handleLimitBlur, limitHasError };\n}\n"],"names":["useState","produce","useQueryState","props","onChange","value","query","setQuery","lastSyncedQuery","setLastSyncedQuery","handleQueryChange","e","handleQueryBlur","draft","useLimitState","limit","setLimit","toString","lastSyncedLimit","setLastSyncedLimit","limitHasError","test","parseInt","handleLimitChange","handleLimitBlur","limitVal","undefined"],"mappings":"AAAA,oCAAoC;AACpC,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,6CAA6C;AAC7C,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;AAEjC,SAASA,QAAQ,QAAQ,QAAQ;AACjC,SAASC,OAAO,QAAQ,QAAQ;AAMhC;;;;;CAKC,GACD,OAAO,SAASC,cAAcC,KAA4B;IAKxD,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAE,GAAGF;IAE5B,kCAAkC;IAClC,MAAM,CAACG,OAAOC,SAAS,GAAGP,SAASK,MAAMC,KAAK;IAE9C,gHAAgH;IAChH,kCAAkC;IAClC,MAAM,CAACE,iBAAiBC,mBAAmB,GAAGT,SAASK,MAAMC,KAAK;IAClE,IAAID,MAAMC,KAAK,KAAKE,iBAAiB;QACnCD,SAASF,MAAMC,KAAK;QACpBG,mBAAmBJ,MAAMC,KAAK;IAChC;IAEA,kDAAkD;IAClD,MAAMI,oBAAoB,CAACC;QACzBJ,SAASI;IACX;IAEA,iHAAiH;IACjH,eAAe;IACf,MAAMC,kBAAkB;QACtBH,mBAAmBH;QACnBF,SACEH,QAAQI,OAAO,CAACQ;YACdA,MAAMP,KAAK,GAAGA;QAChB;IAEJ;IAEA,OAAO;QAAEA;QAAOI;QAAmBE;IAAgB;AACrD;AAEA;;CAEC,GACD,OAAO,SAASE,cAAcX,KAA4B;IAMxD,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAE,GAAGF;IAE5B,+EAA+E;IAC/E,MAAM,CAACY,OAAOC,SAAS,GAAGhB,SAASK,MAAMU,KAAK,GAAGV,MAAMU,KAAK,CAACE,QAAQ,KAAK;IAC1E,MAAM,CAACC,iBAAiBC,mBAAmB,GAAGnB,SAASK,MAAMU,KAAK;IAClE,IAAIV,MAAMU,KAAK,KAAKG,iBAAiB;QACnCF,SAASX,MAAMU,KAAK,GAAGV,MAAMU,KAAK,CAACE,QAAQ,KAAK;QAChDE,mBAAmBd,MAAMU,KAAK;IAChC;IAEA,wCAAwC;IACxC,MAAMK,gBAAgB,CAAEL,CAAAA,UAAU,MAAO,WAAWM,IAAI,CAACN,UAAUO,SAASP,SAAS,CAAC;IAEtF,2CAA2C;IAC3C,MAAMQ,oBAAoB,CAACZ;QACzBK,SAASL;IACX;IAEA,mFAAmF;IACnF,MAAMa,kBAAkB;QACtB,IAAIJ,eAAe;YACjB;QACF;QAEA,MAAMK,WAAWV,UAAU,KAAKW,YAAYJ,SAASP;QACrDI,mBAAmBM;QACnBrB,SACEH,QAAQI,OAAO,CAACQ;YACdA,MAAME,KAAK,GAAGU;QAChB;IAEJ;IAEA,OAAO;QAAEV;QAAOQ;QAAmBC;QAAiBJ;IAAc;AACpE"}