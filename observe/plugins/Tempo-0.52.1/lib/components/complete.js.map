{"version":3,"sources":["../../../src/components/complete.ts"],"sourcesContent":["// Copyright 2024 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Completion, CompletionContext, CompletionResult, insertCompletionText } from '@codemirror/autocomplete';\nimport { syntaxTree } from '@codemirror/language';\nimport { EditorState } from '@codemirror/state';\nimport { Tree } from '@lezer/common';\nimport {\n  String as StringType,\n  FieldExpression,\n  AttributeField,\n  Resource,\n  Identifier,\n  Span,\n  SpansetFilter,\n  FieldOp,\n} from '@grafana/lezer-traceql';\nimport { EditorView } from '@uiw/react-codemirror';\nimport { isAbsoluteTimeRange, TimeRangeValue, toAbsoluteTimeRange } from '@perses-dev/core';\nimport { CompletionConfig } from './TraceQLExtension';\n\n/** CompletionScope specifies the completion kind, e.g. whether to complete tag names or values etc. */\ntype CompletionScope =\n  | { kind: 'Scopes' } // 'resource'|'span'\n  | { kind: 'TagName'; scope: 'resource' | 'span' | 'intrinsic' }\n  | { kind: 'TagValue'; tag: string };\n\n/**\n * Completions specifies the identified scopes and position of the completion in the current editor text.\n * For example, when entering '{' the following completions are possible: Scopes(), TagName(scope=intrinsic)\n */\nexport interface Completions {\n  scopes: CompletionScope[];\n  from: number;\n  to?: number;\n}\n\nexport async function complete(\n  completionCfg: CompletionConfig,\n  { state, pos }: CompletionContext\n): Promise<CompletionResult | null> {\n  // First, identify the completion scopes, for example Scopes() and TagName(scope=intrinsic)\n  const completions = identifyCompletions(state, pos, syntaxTree(state));\n  if (!completions) {\n    // No completion scopes found for current cursor position.\n    return null;\n  }\n\n  // Then, retrieve completion options for all identified scopes (from the Tempo API).\n  const options = await retrieveOptions(completionCfg, completions.scopes);\n  return { options, from: completions.from, to: completions.to };\n}\n\n/**\n * Identify completion scopes (e.g. TagValue) and position, based on the current node in the syntax tree.\n *\n * For development, you can visualize the tree of a TraceQL query using this tool:\n * https://github.com/grafana/lezer-traceql/blob/main/tools/tree-viz.html\n *\n * Function is exported for tests only.\n */\nexport function identifyCompletions(state: EditorState, pos: number, tree: Tree): Completions | undefined {\n  const node = tree.resolveInner(pos, -1);\n\n  switch (node.type.id) {\n    case SpansetFilter:\n      // autocomplete {\n      // autocomplete {}\n      // do not autocomplete if cursor is after } or { status=ok }\n      if (\n        (node.firstChild === null || node.firstChild?.type.id === 0) &&\n        !state.sliceDoc(node.from, pos).includes('}')\n      ) {\n        return {\n          scopes: [{ kind: 'Scopes' }, { kind: 'TagName', scope: 'intrinsic' }],\n          from: pos,\n        };\n      }\n      break;\n\n    case FieldExpression:\n      // autocomplete { status=ok &&\n      return {\n        scopes: [{ kind: 'Scopes' }, { kind: 'TagName', scope: 'intrinsic' }],\n        from: pos,\n      };\n\n    case AttributeField:\n      // autocomplete { resource.\n      if (node.firstChild?.type.id === Resource) {\n        return { scopes: [{ kind: 'TagName', scope: 'resource' }], from: pos };\n      }\n\n      // autocomplete { span.\n      if (node.firstChild?.type.id === Span) {\n        return { scopes: [{ kind: 'TagName', scope: 'span' }], from: pos };\n      }\n\n      // autocomplete { .\n      if (state.sliceDoc(node.from, node.to) === '.') {\n        return {\n          scopes: [\n            { kind: 'TagName', scope: 'resource' },\n            { kind: 'TagName', scope: 'span' },\n          ],\n          from: pos,\n        };\n      }\n      break;\n\n    case Identifier:\n      if (node.parent?.type.id === AttributeField) {\n        const text = state.sliceDoc(node.parent.from, node.parent.to);\n        // autocomplete { span:s\n        // only intrinsic fields can have a : in the name.\n        if (text.includes(':')) {\n          return { scopes: [{ kind: 'TagName', scope: 'intrinsic' }], from: node.parent.from };\n        }\n\n        // autocomplete { resource.s\n        if (node.parent?.firstChild?.type.id === Resource) {\n          return { scopes: [{ kind: 'TagName', scope: 'resource' }], from: node.from };\n        }\n\n        // autocomplete { span.s\n        if (node.parent?.firstChild?.type.id === Span) {\n          return { scopes: [{ kind: 'TagName', scope: 'span' }], from: node.from };\n        }\n\n        // autocomplete { .s\n        if (node.parent?.firstChild?.type.id === Identifier) {\n          return {\n            scopes: [\n              { kind: 'TagName', scope: 'resource' },\n              { kind: 'TagName', scope: 'span' },\n            ],\n            from: node.from,\n          };\n        }\n      }\n      break;\n\n    case FieldOp:\n      // autocomplete { status=\n      // autocomplete { span.http.method=\n      if (node.parent?.firstChild?.type.id === FieldExpression) {\n        const fieldExpr = node.parent.firstChild;\n        const attribute = state.sliceDoc(fieldExpr.from, fieldExpr.to);\n        return { scopes: [{ kind: 'TagValue', tag: attribute }], from: pos };\n      }\n      break;\n\n    case StringType:\n      // autocomplete { resource.service.name=\"\n      // do not autocomplete if cursor is after closing quotes { resource.service.name=\"\"\n      if (\n        node.parent?.parent?.parent?.firstChild?.type.id === FieldExpression &&\n        !/^\".*\"$/.test(state.sliceDoc(node.from, pos))\n      ) {\n        const fieldExpr = node.parent.parent.parent.firstChild;\n        const attribute = state.sliceDoc(fieldExpr.from, fieldExpr.to);\n        return { scopes: [{ kind: 'TagValue', tag: attribute }], from: node.from + 1 }; // node.from+1 to ignore leading \"\n      }\n      break;\n\n    case 0 /* error node */:\n      // autocomplete { status=e\n      if (node.prevSibling?.type.id === FieldOp && node.parent?.firstChild?.type.id === FieldExpression) {\n        const fieldExpr = node.parent.firstChild;\n        const attribute = state.sliceDoc(fieldExpr.from, fieldExpr.to);\n        // ignore leading \" in { name=\"HT\n        const from = state.sliceDoc(node.from, node.from + 1) === '\"' ? node.from + 1 : node.from;\n        return { scopes: [{ kind: 'TagValue', tag: attribute }], from };\n      }\n\n      // autocomplete { s\n      // autocomplete { status=ok && s\n      if (node.parent?.type.id === SpansetFilter || node.parent?.type.id === FieldExpression) {\n        return {\n          scopes: [{ kind: 'Scopes' }, { kind: 'TagName', scope: 'intrinsic' }],\n          from: node.from,\n        };\n      }\n      break;\n  }\n}\n\n/**\n * Retrieve all completion options based on the previously identified completion scopes.\n */\nasync function retrieveOptions(completionCfg: CompletionConfig, completions: CompletionScope[]): Promise<Completion[]> {\n  const results: Array<Promise<Completion[]>> = [];\n\n  for (const completion of completions) {\n    switch (completion.kind) {\n      case 'Scopes':\n        results.push(Promise.resolve([{ label: 'span' }, { label: 'resource' }]));\n        break;\n\n      case 'TagName':\n        results.push(completeTagName(completionCfg, completion.scope));\n        break;\n\n      case 'TagValue':\n        results.push(completeTagValue(completionCfg, completion.tag));\n        break;\n    }\n  }\n\n  // Retrieve options concurrently\n  // e.g. for unscoped attribute fields, retrieve list of span and resource attributes concurrently.\n  const options = await Promise.all(results);\n  return options.flat();\n}\n\nfunction getUnixTimeRange(timeRange?: TimeRangeValue): { start?: number; end?: number } {\n  if (!timeRange) {\n    return {};\n  }\n\n  const absTimeRange = !isAbsoluteTimeRange(timeRange) ? toAbsoluteTimeRange(timeRange) : timeRange;\n  const start = Math.round(absTimeRange.start.getTime() / 1000);\n  const end = Math.round(absTimeRange.end.getTime() / 1000);\n  return { start, end };\n}\n\nasync function completeTagName(\n  completionCfg: CompletionConfig,\n  scope: 'resource' | 'span' | 'intrinsic'\n): Promise<Completion[]> {\n  if (!completionCfg.client) {\n    return [];\n  }\n\n  const { start, end } = getUnixTimeRange(completionCfg.timeRange);\n  const { limit, maxStaleValues } = completionCfg;\n\n  const response = await completionCfg.client.searchTags({ scope, start, end, limit, maxStaleValues });\n  return response.scopes.flatMap((scope) => scope.tags).map((tag) => ({ label: tag }));\n}\n\n/**\n * Add quotes to the completion text in case quotes are not present already.\n * This handles the following cases:\n * { name=HTTP\n * { name=\"x\n * { name=\"x\" where cursor is after the 'x'\n */\nfunction applyQuotedCompletion(view: EditorView, completion: Completion, from: number, to: number): void {\n  let insertText = completion.label;\n  if (view.state.sliceDoc(from - 1, from) !== '\"') {\n    insertText = '\"' + insertText;\n  }\n  if (view.state.sliceDoc(to, to + 1) !== '\"') {\n    insertText = insertText + '\"';\n  }\n  view.dispatch(insertCompletionText(view.state, insertText, from, to));\n}\n\nasync function completeTagValue(completionCfg: CompletionConfig, tag: string): Promise<Completion[]> {\n  if (!completionCfg.client) {\n    return [];\n  }\n\n  const { start, end } = getUnixTimeRange(completionCfg.timeRange);\n  const { limit, maxStaleValues } = completionCfg;\n\n  const response = await completionCfg.client.searchTagValues({ tag, start, end, limit, maxStaleValues });\n  const completions: Completion[] = [];\n  for (const { type, value } of response.tagValues) {\n    switch (type) {\n      case 'string':\n        completions.push({ label: value ?? '', displayLabel: value ?? '(empty string)', apply: applyQuotedCompletion });\n        break;\n\n      case 'keyword':\n      case 'int':\n        completions.push({ label: value ?? '', displayLabel: value ?? '(empty string)' });\n        break;\n    }\n  }\n  return completions;\n}\n"],"names":["insertCompletionText","syntaxTree","String","StringType","FieldExpression","AttributeField","Resource","Identifier","Span","SpansetFilter","FieldOp","isAbsoluteTimeRange","toAbsoluteTimeRange","complete","completionCfg","state","pos","completions","identifyCompletions","options","retrieveOptions","scopes","from","to","tree","node","resolveInner","type","id","firstChild","sliceDoc","includes","kind","scope","parent","text","fieldExpr","attribute","tag","test","prevSibling","results","completion","push","Promise","resolve","label","completeTagName","completeTagValue","all","flat","getUnixTimeRange","timeRange","absTimeRange","start","Math","round","getTime","end","client","limit","maxStaleValues","response","searchTags","flatMap","tags","map","applyQuotedCompletion","view","insertText","dispatch","searchTagValues","value","tagValues","displayLabel","apply"],"mappings":"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"}